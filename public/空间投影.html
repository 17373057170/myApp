<!DOCTYPE HTML>
<html>
    <head>
        <title>空间投影</title>
        <style type = "text/css">
            body{ margin:0; font-family:"黑体"; font-size:20px; background:#E9E9E9;}
            #container { margin:0 auto; margin-top:5px; width:1200px; padding:5px; background:#FFFFFF;}
            #header { margin-bottom:10px; background:rgb(187, 181, 181);}
            .containCanvas{ margin:0 auto;background: rgb(243, 215, 220);}
        </style>
    </head>
    <body>        
        <div id = "container">
            <div id = "header">
                <input id = "openMapFile" type = "file" onchange = "readMapFile()"/>  <br>
                <input id = "LambertButtom" type = "button" value = "兰伯特投影" onclick = "setLambertSign()"/>
                <input id = "MercatorButtom" type = "button" value = "墨卡托投影" onclick = "setMercatorSign()"/>
            </div>
            <div id = "canvasDiv" class = "containCanvas">
                    <canvas id = "mapDrawing"/>
            </div>
        </div>
    
        <script type = "text/Javascript">
            var projectSign = 0;        //投影类型代号
            var myMap = new Array();    //首位记录总线段数

            //当前投影设定为兰伯特投影并在屏幕上重新绘制，代号为1
            function setLambertSign() 
            { 
                projectSign = 1; 
                drawMap(myMap);
            }
            //当前投影为墨卡托投影并在屏幕上重新绘制，代号为2
            function setMercatorSign() 
            { 
                projectSign = 2; 
                drawMap(myMap);
            }
            //读取地图文件
            function readMapFile()
            {  
                projectSign = 0;        //将投影标识设置为0
                var mapFile = document.getElementById("openMapFile").files[0];  //获取文件
                var reader = new FileReader();  
                reader.readAsText(mapFile);  
                reader.onload=function(e)
                {
                    myMap = mapStr2mapXY(this.result)   //将读取的字符串转为数字
                    //document.write(myMap);
                    drawMap(myMap);     //绘制原始地图
                }     
            }
            //将字符串形式转换为数字形式
            function mapStr2mapXY(mapStr)
            {
                var lineNum = 1;        //记录已经读取行数
                var pointNum = 0;       //记录当前线点数
                var mapXY = new Array();  
                var strs = mapStr.split("\n");     //设置分割
                for (var i = 0; i <= strs.length ;i++)
                {
                    if( i == 0)   //为第一条线增加存储空间
                    {
                        mapXY[lineNum] = new Array();
                        i++;
                    }
                    if(strs[i].indexOf("END") >= 0)
                    {
                        if(strs[i+1].indexOf("END") >= 0)    //文件结束
                        {
                            mapXY[0] = lineNum;
                            return mapXY;
                        }
                        else                                //当前线段结束
                        {
                            mapXY[++lineNum] = new Array(); //为下一条线分配空间
                            i += 2;
                            pointNum = 0;
                        }
                    }

                    //将该点记录进入数组
                    var XY = strs[i].split(',');
                    mapXY[lineNum][pointNum] = new Array(2);       //分配存储空间
                    mapXY[lineNum][pointNum][0] = parseFloat(XY[0]);
                    mapXY[lineNum][pointNum++][1] = parseFloat(XY[1]);
                }//for
            }
            //找到地图的起始边界
            function findBorder(mapArray)
            {
                var maxX = -20100000, maxY = -20100000, minX = 20100000, minY = 20100000; //设置经纬度最大最小标志
                var lineNum = mapArray.length, pointNum;
                var corX, corY;
                for (var i = 1; i < lineNum; i++)
                {
                    lineArray = mapArray[i]
                    pointNum = lineArray.length;
                    for (var j = 0; j < pointNum; j++)
                    {
                        corX = lineArray[j][0], corY = lineArray[j][1];
                        if (corX < minX)    minX = corX;
                        if (corX > maxX)    maxX = corX;
                        if (corY < minY)    minY = corY;
                        if (corY > maxY)    maxY = corY;
                    }//for point j
                }//for line i
                var borderArray = new Array(minX, maxX, minY, maxY);
                return borderArray;
            }
            function An2Ra(angle)
            {
	            return (angle / 180) * Math.PI;
            }

            //进行兰伯特投影转换
            function LambertTransition(mapDraw)
            {
                //投影转化算法
                function LambertTXY(B, L, B0, B1, B2, L0, a, b, e2)
                {
	                //将原始参数转变为弧度制
	                B0 = An2Ra(B0);
	                B1 = An2Ra(B1);
	                B2 = An2Ra(B2);
	                L0 = An2Ra(L0);
	                //将原始数据转化为弧度制
	                B = An2Ra(B);
	                L = An2Ra(L);
                    
    	            //获得B1B2的m值
	                var mB1 = Math.cos(B1) / Math.sqrt(1 - e2*Math.sin(B1)*Math.sin(B1));
	                var mB2 = Math.cos(B2) / Math.sqrt(1 - e2*Math.sin(B2)*Math.sin(B2));
	                //获得B0B1B2的t值
	                var tB0 = Math.tan(Math.PI/4 - B0/2) / Math.sqrt((1 - Math.sqrt(e2)*Math.sin(B0)) / ((1 + Math.sqrt(e2)*Math.sin(B0)), Math.sqrt(e2)/2));
    	            var tB1 = Math.tan(Math.PI/4 - B1/2) / Math.sqrt((1 - Math.sqrt(e2)*Math.sin(B1)) / ((1 + Math.sqrt(e2)*Math.sin(B1)), Math.sqrt(e2)/2));
	                var tB2 = Math.tan(Math.PI/4 - B2/2) / Math.sqrt((1 - Math.sqrt(e2)*Math.sin(B2)) / ((1 + Math.sqrt(e2)*Math.sin(B2)), Math.sqrt(e2)/2));
	                //获得n值
	                var n = Math.log(mB1/mB2) / Math.log(tB1/tB2);
	                //获得F值
    	            var F = mB1 / (n * Math.pow(tB1, n));		
	                //获得r0
	                var r0 = a * F * Math.pow(tB0, n);
                	//获得theTa值
	                var theTa = n * (L - L0);
                    
	                //获得B的t值
	                var tB = Math.tan(Math.PI/4 - B/2) / Math.sqrt((1 - Math.sqrt(e2)*Math.sin(B)) / ((1 + Math.sqrt(e2)*Math.sin(B)), Math.sqrt(e2)/2));
            	    //获得r值
	                var r = a * F * Math.pow(tB, n); 
                    
	                //计算坐标
	                var XL = r * Math.sin(theTa);	//经度
	                var YB = r0 - r * Math.cos(theTa);	//纬度
            	    var XY = new Array(XL, YB);
	                return XY;
                }
                for (var i = 1; i <= mapDraw[0][0]; i++)
                {
                    var eachLine = mapDraw[i];
                    for (var j = 0; j < eachLine.length; j++)
                        eachLine[j] = LambertTXY(eachLine[j][1], eachLine[j][0], 0, 20, 40, 105, 6378245, 6356863.01877, 0.006693421622966)
                }
                return mapDraw;
            }
            //进行墨卡托投影转换
            function MercatorTransition(mapDraw)
            {
                //投影转化算法
                function MercatorTXY(B, L, B0, L0, a, b, e2, e_2)
                {
                    //绘制85到-85的范围
                    if (B == 90)	B = 86;
	                if (B == -90)	B = -86;

	                //将原始参数转变为弧度制
	                B0 = An2Ra(B0);
	                L0 = An2Ra(L0);
	                //将原始数据转化为弧度制
	                B = An2Ra(B);
	                L = An2Ra(L);
	
	                //求B0的N值
	                var NB0 = ((a*a) / b) / Math.sqrt(1 + e_2 * Math.cos(B0)*Math.cos(B0));
	                //求K值
	                var K = NB0 * Math.cos(B0);
                	//计算坐标
	                var XL = K * (L - L0);
	                var YB = K * Math.log(Math.tan(Math.PI/4 + B/2)*Math.pow(((1 - Math.sqrt(e2)*Math.sin(B))/(1 - Math.sqrt(e2)*Math.sin(B))), Math.sqrt(e2)/2))

                	var XY = new Array(XL, YB);
                	return XY;
                }
                for (var i = 1; i <= mapDraw[0][0]; i++)
                {
                    var eachLine = mapDraw[i];
                    for (var j = 0; j < eachLine.length; j++)
                        eachLine[j] =MercatorTXY(eachLine[j][1], eachLine[j][0], 0, 0, 6378245, 6356863.01877, 0.006693421622966, 0.006738525414684);
                }
                return mapDraw;
            }
            //加入网格并进行投影转换
            function completeMap(mapArray)
            {
                var mapDraw = new Array();      //存储需要绘制的图形数据，全部以点的形式存储

                //存储网格数据
                var borderList = findBorder(mapArray);
                var leftBorder, rightBorder, bottomBorder, topBorder;
                if (borderList[0] < 0)  leftBorder = parseInt(borderList[0]/5) - 1;
                else    leftBorder = parseInt(borderList[0]/5);
                if (borderList[1] < 0)  rightBorder = parseInt(borderList[1]/5);
                else    rightBorder = parseInt(borderList[1]/5) + 1;
                if (borderList[2] < 0)  bottomBorder = parseInt(borderList[2]/5) - 1;
                else    bottomBorder = parseInt(borderList[2]/5);
                if (borderList[3] < 0)  topBorder = parseInt(borderList[3]/5);
                else    topBorder = parseInt(borderList[3]/5) + 1;
                var longLineNum = rightBorder - leftBorder -1, latLineNum = topBorder - bottomBorder - 1;
                var longLineLen = (latLineNum + 1) * 5, latLineLen = (longLineNum + 1) * 5;
                //存储竖线数据
                for (var i = 1; i <= longLineNum; i++)
                {
                    mapDraw[i] = new Array(2);
                    mapDraw[i][0] = new Array((leftBorder + i)*5, bottomBorder*5);
                    mapDraw[i][1] = new Array((leftBorder + i)*5, bottomBorder*5 + longLineLen);
                }
                //存储横线数据
                for (var i = 1; i <= latLineNum; i++)
                {
                    mapDraw[i + longLineNum] = new Array(2);
                    mapDraw[i + longLineNum][0] = new Array(leftBorder*5, (bottomBorder + i)*5);
                    mapDraw[i + longLineNum][1] = new Array(leftBorder*5 + latLineLen, (bottomBorder + i)*5);                    
                }

                //存储地图数据
                var mapLineNum = mapArray[0];
                for (var i = 1; i <= mapLineNum; i++)
                {
                    mapDraw[i +longLineNum + latLineNum] = new Array();
                    mapDraw[i + longLineNum + latLineNum] = mapArray[i].slice();
                }
                //记录用于所有线总数，画网格的线条数，地图线段数
                mapDraw[0] = new Array(mapDraw.length - 1, longLineNum + latLineNum, mapArray[0]) ; 
                //document.write(mapDraw);

                switch(projectSign)
                {
                case 0://原始经纬度数据显示
                    break;
                case 1://兰伯特投影
                    mapDraw = LambertTransition(mapDraw);
                    break;
                case 2://墨卡托投影
                    mapDraw = MercatorTransition(mapDraw);
                    break;
                }

                return mapDraw;
            }
            function drawMap(mapArray)
            {
                var rawDrawPoints = completeMap(mapArray, projectSign);
                //获得画布的长宽定标
                var mapDrawBorder = findBorder(rawDrawPoints);
                var W2HRatio = (mapDrawBorder[1] - mapDrawBorder[0]) / (mapDrawBorder[3] - mapDrawBorder[2]);
                var interval, minX = mapDrawBorder[0], minY = mapDrawBorder[2] ,maxY = mapDrawBorder[3];
                if (W2HRatio >= 1.5)
                    interval = 900/(mapDrawBorder[1] - mapDrawBorder[0]);
                else
                    interval = 600/(mapDrawBorder[3] - mapDrawBorder[2]);
                var mapWidth = interval * (mapDrawBorder[1] - mapDrawBorder[0]);
                var mapHeight = interval * (mapDrawBorder[3] - mapDrawBorder[2]);

                //设置画布长宽
                var mapDrawDiv = document.getElementById("canvasDiv");
                mapDrawDiv.style.height = mapHeight + "px";
                mapDrawDiv.style.width = mapWidth + "px";
                var myCanvas = document.getElementById("mapDrawing");
                myCanvas.width = mapWidth;
                myCanvas.height = mapHeight;

                //绘制
                var drawCanvas = myCanvas.getContext("2d");
                //绘制格网
                drawCanvas.lineWidth = 1;                           //设置线宽
                drawCanvas.strokeStyle = "gray";                    //设置线色
                for (var i = 1; i <= rawDrawPoints[0][1]; i++)
                {
                    var lineList = rawDrawPoints[i];
                    drawCanvas.beginPath();
                    drawCanvas.moveTo((lineList[0][0] - minX) * interval, (maxY - lineList[0][1]) * interval);
                    for (var j = 1; j < lineList.length; j++)
                        drawCanvas.lineTo((lineList[j][0]- minX) * interval, (maxY - lineList[j][1]) * interval);
                    drawCanvas.stroke();                                //绘制线条
                }
                //绘制地图
                drawCanvas.lineWidth = 2;                           //设置线宽
                drawCanvas.strokeStyle = "purple";                    //设置线色
                for (var i = rawDrawPoints[0][1] + 1; i <= rawDrawPoints[0][0]; i++)
                {
                    var lineList = rawDrawPoints[i];
                    drawCanvas.beginPath();
                    drawCanvas.moveTo((lineList[0][0] - minX) * interval, (maxY - lineList[0][1]) * interval);
                    for (var j = 1; j < lineList.length; j++)
                        drawCanvas.lineTo((lineList[j][0]- minX) * interval, (maxY - lineList[j][1]) * interval);
                    drawCanvas.stroke();                                //绘制线条
                }
            }
        </script>
    </body>
</html>